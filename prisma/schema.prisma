generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                               String                   @id @default(cuid())
  name                             String
  email                            String                   @unique
  phone                            String?
  emailVerified                    DateTime?
  image                            String?
  password                         String
  role                             Role
  status                           UserStatus               @default(PENDING)
  disciplineId                     String?
  representantId                   String? // Représentant assigné (pour auteurs)
  lastLoginAt                      DateTime? // Dernière connexion
  createdAt                        DateTime                 @default(now())
  updatedAt                        DateTime                 @updatedAt
  accounts                         Account[]
  receivedMessages                 Message[]                @relation("ReceivedMessages")
  sentMessages                     Message[]                @relation("SentMessages")
  notifications                    Notification[]
  orders                           Order[]
  partnerClients                   Partner[]                @relation("PartnerRepresentant")
  partner                          Partner?
  conceivedProjects                Project[]                @relation("ConceptorProjects")
  reviewedProjects                 Project[]                @relation("ReviewedProjects")
  royalties                        Royalty[]
  sessions                         Session[]
  resolvedAlerts                   StockAlert[]
  createdAlertRules                StockAlertRule[]
  createdIntegrations              StockIntegration[]
  performedStockMovements          StockMovement[]          @relation("StockMovements")
  createdReports                   StockReport[]
  validatedPartnerRebates          PartnerRebate[]          @relation("ValidatedPartnerRebates")
  createdRebateRates               RebateRate[]             @relation("CreatedRebateRates")
  authorRebateRates                RebateRate[]             @relation("AuthorRebateRates")
  discipline                       Discipline?              @relation(fields: [disciplineId], references: [id])
  representant                     User?                    @relation("RepresentantAuthors", fields: [representantId], references: [id], onDelete: SetNull)
  managedAuthors                   User[]                   @relation("RepresentantAuthors")
  authoredWorks                    Work[]                   @relation("AuthorWorks")
  conceivedWorks                   Work[]                   @relation("ConceptorWorks")
  reviewedWorks                    Work[]                   @relation("ReviewedWorks")
  workSales                        WorkSale[]
  createdWorkVersions              WorkVersion[]
  workViews                        WorkView[]
  generatedDeliveryNotes           DeliveryNote[]           @relation("GeneratedDeliveryNotes")
  validatedDeliveryNotes           DeliveryNote[]           @relation("ValidatedDeliveryNotes")
  controlledDeliveryNotes          DeliveryNote[]           @relation("ControlledDeliveryNotes")
  stockRequests                    StockRequest[]           @relation("StockRequests")
  approvedStockRequests            StockRequest[]           @relation("ApprovedStockRequests")
  notificationChains               NotificationChain[]      @relation("NotificationChains")
  createdNotificationChains        NotificationChain[]      @relation("CreatedNotificationChains")
  createdNotificationTemplates     NotificationTemplate[]   @relation("CreatedNotificationTemplates")
  updatedNotificationTemplates     NotificationTemplate[]   @relation("UpdatedNotificationTemplates")
  updatedAdvancedSettings          AdvancedSetting[]        @relation("UpdatedAdvancedSettings")
  createdProformas                 Proforma[]               @relation("CreatedProformas")
  userProformas                    Proforma[]               @relation("UserProformas")
  authorWithdrawals                Withdrawal[]             @relation("AuthorWithdrawals")
  validatedWithdrawals             Withdrawal[]             @relation("ValidatedWithdrawals")
  representantWithdrawals          RepresentantWithdrawal[] @relation("RepresentantWithdrawals")
  validatedRepresentantWithdrawals RepresentantWithdrawal[] @relation("ValidatedRepresentantWithdrawals")
  recordedPayments                 Payment[]                @relation("RecordedPayments")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Project {
  id                   String        @id @default(cuid())
  title                String
  description          String?
  objectives           String?
  expectedDeliverables String?
  requiredResources    String?
  timeline             String?
  rejectionReason      String?
  disciplineId         String
  status               ProjectStatus @default(DRAFT)
  submittedAt          DateTime?
  reviewedAt           DateTime?
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt
  concepteurId         String
  reviewerId           String?
  concepteur           User          @relation("ConceptorProjects", fields: [concepteurId], references: [id])
  discipline           Discipline    @relation(fields: [disciplineId], references: [id])
  reviewer             User?         @relation("ReviewedProjects", fields: [reviewerId], references: [id])
  works                Work[]        @relation("ProjectWorks")
}

model Work {
  id                    String             @id @default(cuid())
  title                 String
  description           String?
  isbn                  String             @unique
  internalCode          String?
  price                 Float              @default(0)
  tva                   Float              @default(0.18)
  discountRate          Float?
  stock                 Int                @default(0)
  minStock              Int                @default(10)
  maxStock              Int?
  physicalStock         Int                @default(0)
  category              String?
  targetAudience        String?
  educationalObjectives String?
  contentType           String?
  keywords              String?
  files                 String?
  validationComment     String?
  rejectionReason       String?
  disciplineId          String
  status                WorkStatus         @default(PENDING)
  publishedAt           DateTime?
  publicationDate       DateTime?
  version               String?
  submittedAt           DateTime?
  reviewedAt            DateTime?
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @default(now()) @updatedAt
  authorId              String
  reviewerId            String?
  concepteurId          String?
  projectId             String?
  orderItems            OrderItem[]
  partnerStocks         PartnerStock[]
  proformaItems         ProformaItem[]     @relation("ProformaItemWork")
  royalties             Royalty[]
  sales                 Sale[]
  stockAlerts           StockAlert[]
  stockMovements        StockMovement[]
  partnerRebates        PartnerRebate[]    @relation("WorkPartnerRebates")
  rebateRates           RebateRate[]       @relation("WorkRebateRates")
  author                User               @relation("AuthorWorks", fields: [authorId], references: [id])
  concepteur            User?              @relation("ConceptorWorks", fields: [concepteurId], references: [id])
  discipline            Discipline         @relation(fields: [disciplineId], references: [id])
  project               Project?           @relation("ProjectWorks", fields: [projectId], references: [id])
  reviewer              User?              @relation("ReviewedWorks", fields: [reviewerId], references: [id])
  workDistributions     WorkDistribution[]
  workSales             WorkSale[]
  versions              WorkVersion[]
  workViews             WorkView[]
  stockRequestItems     StockRequestItem[]

  @@index([status, disciplineId])
  @@index([authorId, status])
  @@index([stock])
  @@index([createdAt])
}

model StockMovement {
  id               String            @id @default(cuid())
  workId           String
  type             StockMovementType
  quantity         Int
  reason           String?
  reference        String?
  performedBy      String?
  partnerId        String?
  source           String?
  destination      String?
  unitPrice        Float?
  totalAmount      Float?
  isCorrection     Boolean           @default(false)
  correctionReason String?
  createdAt        DateTime          @default(now())
  partner          Partner?          @relation(fields: [partnerId], references: [id])
  performedByUser  User?             @relation("StockMovements", fields: [performedBy], references: [id])
  work             Work              @relation(fields: [workId], references: [id])

  @@index([workId])
  @@index([type])
  @@index([createdAt])
  @@index([partnerId])
  @@index([isCorrection])
}

model Discipline {
  id          String    @id @default(cuid())
  name        String    @unique
  description String?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  projects    Project[]
  users       User[]
  works       Work[]
}

model Sale {
  id        String   @id @default(cuid())
  workId    String
  quantity  Int
  amount    Float
  createdAt DateTime @default(now())
  work      Work     @relation(fields: [workId], references: [id])
}

model Partner {
  id             String          @id @default(cuid())
  name           String
  type           String
  address        String?
  phone          String?
  email          String?
  contact        String?
  website        String?
  description    String?
  representantId String?
  userId         String          @unique
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  orders         Order[]         @relation("PartnerOrders")
  representant   User?           @relation("PartnerRepresentant", fields: [representantId], references: [id])
  user           User            @relation(fields: [userId], references: [id])
  stockItems     PartnerStock[]
  stockMovements StockMovement[]
  proformas      Proforma[]      @relation("PartnerProformas")
  rebates        PartnerRebate[]
  rebateRates    RebateRate[]
}

model PartnerStock {
  id                String   @id @default(cuid())
  partnerId         String
  workId            String
  allocatedQuantity Int
  soldQuantity      Int      @default(0)
  returnedQuantity  Int      @default(0)
  // availableQuantity supprimé - calculé à la lecture: allocatedQuantity - soldQuantity + returnedQuantity
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  partner           Partner  @relation(fields: [partnerId], references: [id])
  work              Work     @relation(fields: [workId], references: [id])

  @@unique([partnerId, workId])
  @@index([partnerId])
  @@index([workId])
}

model Order {
  id                 String              @id @default(cuid())
  userId             String
  partnerId          String?
  paymentMethod      String? // Mobile Money, Virement, Espèces, Carte Bancaire
  paymentReference   String? // Référence de transaction
  paymentType        PaymentType         @default(CASH) // Type: Comptant, Dépôt, Crédit
  amountPaid         Float               @default(0) // Montant versé/payé
  remainingAmount    Float               @default(0) // Reste à payer
  depositAmount      Float? // Montant du dépôt initial (si paymentType = DEPOSIT)
  depositDate        DateTime? // Date du versement du dépôt
  fullPaymentDate    DateTime? // Date du paiement complet
  paymentStatus      PaymentStatus       @default(UNPAID) // État du paiement
  deliveryDate       DateTime? // Date de livraison prévue/effective
  deliveryStatus     DeliveryStatus      @default(PENDING) // État de livraison
  receivedAt         DateTime? // Date de réception par le client
  receivedBy         String? // Nom de la personne ayant réceptionné
  subtotal           Float               @default(0)
  tax                Float               @default(0)
  discount           Float               @default(0) // Réduction appliquée (code promo)
  promoCode          String? // Code promo utilisé
  total              Float               @default(0)
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @default(now()) @updatedAt
  status             OrderStatus         @default(PENDING)
  partner            Partner?            @relation("PartnerOrders", fields: [partnerId], references: [id])
  user               User                @relation(fields: [userId], references: [id])
  items              OrderItem[]
  deliveryNote       DeliveryNote?
  stockRequests      StockRequest[]      @relation("StockRequestOrders")
  notificationChains NotificationChain[] @relation("NotificationChainOrders")
  proforma           Proforma?           @relation("ProformaOrder")
  royalties          Royalty[]           @relation("OrderRoyalties")
  partnerRebates     PartnerRebate[]     @relation("OrderPartnerRebates")
  payments           Payment[]           @relation("OrderPayments")

  @@index([promoCode])
  @@index([paymentType])
  @@index([paymentStatus])
  @@index([deliveryStatus])
  @@index([userId, status, createdAt])
  @@index([partnerId, status])
  @@index([status, createdAt])
}

model OrderItem {
  id       String @id @default(cuid())
  orderId  String
  workId   String
  quantity Int
  price    Float
  order    Order  @relation(fields: [orderId], references: [id])
  work     Work   @relation(fields: [workId], references: [id])
}

model Payment {
  id               String   @id @default(cuid())
  orderId          String
  amount           Float // Montant du paiement
  paymentMethod    String // Mobile Money, Virement, Espèces, etc.
  paymentReference String? // Référence de transaction
  paymentDate      DateTime @default(now())
  notes            String? // Notes sur le paiement
  recordedById     String // ID de l'utilisateur qui a enregistré le paiement
  recordedBy       User     @relation("RecordedPayments", fields: [recordedById], references: [id])
  order            Order    @relation("OrderPayments", fields: [orderId], references: [id])
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([orderId])
  @@index([paymentDate])
}

model DeliveryNote {
  id             String             @id @default(cuid())
  reference      String             @unique // Référence unique du bon de sortie (ex: BS-2025-001)
  orderId        String             @unique // Lien vers la commande
  order          Order              @relation(fields: [orderId], references: [id])
  generatedById  String // ID de l'utilisateur qui a généré le bon
  generatedBy    User               @relation("GeneratedDeliveryNotes", fields: [generatedById], references: [id])
  validatedById  String? // ID de l'utilisateur qui a validé
  validatedBy    User?              @relation("ValidatedDeliveryNotes", fields: [validatedById], references: [id])
  validatedAt    DateTime? // Date de validation
  controlledById String? // ID de l'utilisateur qui a contrôlé
  controlledBy   User?              @relation("ControlledDeliveryNotes", fields: [controlledById], references: [id])
  controlledAt   DateTime? // Date de contrôle
  status         DeliveryNoteStatus @default(PENDING)
  period         String? // Période (ex: "Vacances et rentrée scolaire")
  notes          String? // Notes additionnelles
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  @@index([orderId])
  @@index([status])
  @@index([createdAt])
  @@index([reference])
}

model Proforma {
  id             String   @id @default(cuid())
  proformaNumber String?  @unique // ex: PF-2026-000023 (temporairement nullable pour migration)
  reference      String?  @unique // Ancien champ pour compatibilité
  country        String   @default("Gabon")
  currency       Currency @default(FCFA)

  clientType ProformaClientType? // Temporairement nullable pour migration
  clientId   String? // nullable car INVITE possible
  partnerId  String? // ID du partenaire (si clientType = PARTENAIRE)
  partner    Partner?            @relation("PartnerProformas", fields: [partnerId], references: [id])
  userId     String? // ID du client (si clientType = CLIENT)
  user       User?               @relation("UserProformas", fields: [userId], references: [id])

  status ProformaStatus @default(DRAFT)

  issuedAt           DateTime  @default(now()) // Date d'émission
  validUntil         DateTime? // Date de validité (temporairement nullable pour migration)
  acceptedAt         DateTime? // Date d'acceptation
  cancelledAt        DateTime? // Date d'annulation
  cancellationReason String? // Raison de l'annulation

  // Totaux (stockés pour éviter recalcul + audit)
  subtotalHT    Float @default(0) // Total HT
  discountTotal Float @default(0) // Remise totale
  taxableBase   Float @default(0) // Base taxable (HT - remise)
  tvaTotal      Float @default(0) // Total TVA
  totalTTC      Float @default(0) // Total TTC

  // Remise globale optionnelle (code promo)
  promoCode         String?
  promoDiscountRate Float? // 0..1 (pourcentage de remise globale)

  // Type de commande (rentrée, vacances, etc.)
  orderType String?

  notes String? // Notes additionnelles / conditions particulières

  createdById String // ID du PDG qui a créé le proforma
  createdBy   User   @relation("CreatedProformas", fields: [createdById], references: [id])

  items          ProformaItem[]
  clientSnapshot ProformaClientSnapshot?

  // Lien éventuel vers une commande / une facture
  orderId          String? @unique
  convertedToOrder Order?  @relation("ProformaOrder", fields: [orderId], references: [id])

  // Versioning (si besoin)
  version          Int        @default(1)
  parentProformaId String?
  parentProforma   Proforma?  @relation("ProformaVersions", fields: [parentProformaId], references: [id])
  versions         Proforma[] @relation("ProformaVersions")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([issuedAt])
  @@index([clientType, clientId])
  @@index([proformaNumber])
}

model ProformaItem {
  id         String   @id @default(cuid())
  proformaId String
  proforma   Proforma @relation(fields: [proformaId], references: [id], onDelete: Cascade)

  // Référence livre à l'instant T (peut être null si livre supprimé)
  workId String?
  work   Work?   @relation("ProformaItemWork", fields: [workId], references: [id])

  // Snapshot des informations du livre (immuable)
  reference  String? // Référence interne
  isbn       String?
  title      String? // Temporairement nullable pour migration
  authorName String?

  quantity    Int
  unitPriceHT Float? // Prix unitaire HT (temporairement nullable pour migration)
  unitPrice   Float? // Ancien champ pour compatibilité

  discountRate Float  @default(0) // 0..1 (pourcentage de remise ligne)
  discount     Float? @default(0) // Ancien champ pour compatibilité
  tvaRate      Float  @default(0.18) // 0..1 (taux TVA, par défaut 18%)

  // Totaux ligne (calculés et stockés)
  lineHT       Float  @default(0) // HT = quantity * unitPriceHT
  lineDiscount Float  @default(0) // Remise = lineHT * discountRate
  lineTaxable  Float  @default(0) // Base taxable = lineHT - lineDiscount
  lineTVA      Float  @default(0) // TVA = lineTaxable * tvaRate
  totalTTC     Float  @default(0) // Total TTC = lineTaxable + lineTVA
  total        Float? @default(0) // Ancien champ pour compatibilité

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt // Temporairement nullable pour migration

  @@index([proformaId])
  @@index([workId])
}

model ProformaClientSnapshot {
  id         String   @id @default(cuid())
  proformaId String   @unique
  proforma   Proforma @relation(fields: [proformaId], references: [id], onDelete: Cascade)

  name    String
  email   String?
  phone   String?
  address String?
  city    String?
  country String?

  createdAt DateTime @default(now())

  @@index([proformaId])
}

model StockRequest {
  id            String             @id @default(cuid())
  reference     String             @unique
  requestedById String
  requestedBy   User               @relation("StockRequests", fields: [requestedById], references: [id])
  approvedById  String?
  approvedBy    User?              @relation("ApprovedStockRequests", fields: [approvedById], references: [id])
  approvedAt    DateTime?
  status        StockRequestStatus @default(PENDING)
  type          StockRequestType
  method        String?
  period        String?
  deliveryDate  DateTime?
  departmentId  String?
  zoneId        String?
  orderId       String?
  order         Order?             @relation("StockRequestOrders", fields: [orderId], references: [id])
  notes         String?
  items         StockRequestItem[]
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  @@index([requestedById])
  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@index([reference])
}

model StockRequestItem {
  id               String       @id @default(cuid())
  requestId        String
  request          StockRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  workId           String
  work             Work         @relation(fields: [workId], references: [id])
  quantity         Int
  approvedQuantity Int?
  createdAt        DateTime     @default(now())

  @@index([requestId])
  @@index([workId])
}

model Royalty {
  id         String    @id @default(cuid())
  workId     String
  userId     String
  amount     Float
  approved   Boolean   @default(false) // Royalties approuvées par le PDG (prêtes à être retirées)
  approvedAt DateTime? // Date d'approbation par le PDG
  paid       Boolean   @default(false) // Royalties déjà payées à l'auteur
  paidAt     DateTime?
  orderId    String? // ID de la commande qui a généré cette royalty
  saleId     String? // ID de la vente directe (si applicable)
  rate       Float? // Taux utilisé pour le calcul (en %)
  createdAt  DateTime  @default(now())
  user       User      @relation(fields: [userId], references: [id])
  work       Work      @relation(fields: [workId], references: [id])
  order      Order?    @relation("OrderRoyalties", fields: [orderId], references: [id])

  @@index([userId])
  @@index([workId])
  @@index([orderId])
  @@index([paid])
  @@index([approved])
  @@index([createdAt])
  @@index([userId, paid, approved])
  @@index([workId, orderId])
}

// Retraits des auteurs (Withdrawals)
model Withdrawal {
  id              String           @id @default(cuid())
  userId          String // ID de l'auteur
  amount          Float // Montant demandé
  method          WithdrawalMethod // Méthode de paiement
  momoNumber      String? // Numéro Mobile Money (si method = MOMO)
  bankName        String? // Nom de la banque (si method = BANK)
  bankAccount     String? // Numéro de compte bancaire (si method = BANK)
  bankAccountName String? // Nom du titulaire du compte
  status          WithdrawalStatus @default(PENDING)
  requestedAt     DateTime         @default(now())
  validatedById   String? // ID du PDG qui a validé
  validatedBy     User?            @relation("ValidatedWithdrawals", fields: [validatedById], references: [id])
  validatedAt     DateTime?
  paidAt          DateTime?
  rejectionReason String? // Raison du rejet (si status = REJECTED)
  notes           String? // Notes internes
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  user            User             @relation("AuthorWithdrawals", fields: [userId], references: [id])

  @@index([userId])
  @@index([status])
  @@index([requestedAt])
}

enum WithdrawalMethod {
  MOMO // Mobile Money (MTN/Moov)
  BANK // Virement bancaire
  CASH // Espèces
}

enum WithdrawalStatus {
  PENDING // En attente de validation
  APPROVED // Approuvé par le PDG
  REJECTED // Rejeté par le PDG
  PAID // Payé
  CANCELLED // Annulé par l'auteur
}

// Retraits des représentants (RepresentantWithdrawals)
model RepresentantWithdrawal {
  id              String           @id @default(cuid())
  userId          String // ID du représentant
  amount          Float // Montant demandé
  method          WithdrawalMethod // Méthode de paiement
  momoNumber      String? // Numéro Mobile Money (si method = MOMO)
  bankName        String? // Nom de la banque (si method = BANK)
  bankAccount     String? // Numéro de compte bancaire (si method = BANK)
  bankAccountName String? // Nom du titulaire du compte
  status          WithdrawalStatus @default(PENDING)
  requestedAt     DateTime         @default(now())
  validatedById   String? // ID du PDG qui a validé
  validatedBy     User?            @relation("ValidatedRepresentantWithdrawals", fields: [validatedById], references: [id])
  validatedAt     DateTime?
  paidAt          DateTime?
  rejectionReason String? // Raison du rejet (si status = REJECTED)
  notes           String? // Notes internes
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  user            User             @relation("RepresentantWithdrawals", fields: [userId], references: [id])

  @@index([userId])
  @@index([status])
  @@index([requestedAt])
}

// Ristournes Partenaires
model PartnerRebate {
  id            String       @id @default(cuid())
  partnerId     String
  orderId       String? // ID de la commande (si applicable)
  saleId        String? // ID de la vente directe (si applicable)
  workId        String? // ID de l'œuvre (si calculé par œuvre)
  amount        Float // Montant de la ristourne
  rate          Float // Taux utilisé (en %)
  status        RebateStatus @default(PENDING)
  validatedById String? // ID du PDG qui a validé
  validatedBy   User?        @relation("ValidatedPartnerRebates", fields: [validatedById], references: [id])
  validatedAt   DateTime?
  paidAt        DateTime?
  notes         String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  partner       Partner      @relation(fields: [partnerId], references: [id])
  order         Order?       @relation("OrderPartnerRebates", fields: [orderId], references: [id])
  work          Work?        @relation("WorkPartnerRebates", fields: [workId], references: [id])

  @@index([partnerId])
  @@index([orderId])
  @@index([status])
  @@index([createdAt])
}

// Taux de ristourne configurables
model RebateRate {
  id          String         @id @default(cuid())
  type        RebateRateType // GLOBAL, PARTNER, AUTHOR, WORK
  partnerId   String? // Si type = PARTNER
  userId      String? // Si type = AUTHOR
  workId      String? // Si type = WORK
  rate        Float // Taux en pourcentage (ex: 15.5 pour 15.5%)
  isActive    Boolean        @default(true)
  startDate   DateTime? // Date de début d'application
  endDate     DateTime? // Date de fin d'application
  createdById String // ID du PDG qui a créé
  createdBy   User           @relation("CreatedRebateRates", fields: [createdById], references: [id])
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  partner     Partner?       @relation(fields: [partnerId], references: [id])
  user        User?          @relation("AuthorRebateRates", fields: [userId], references: [id])
  work        Work?          @relation("WorkRebateRates", fields: [workId], references: [id])

  @@unique([type, partnerId, userId, workId])
  @@index([type])
  @@index([partnerId])
  @@index([userId])
  @@index([workId])
  @@index([isActive])
}

enum RebateStatus {
  PENDING // En attente de validation
  VALIDATED // Validé par le PDG
  PAID // Payé
  CANCELLED // Annulé
}

enum RebateRateType {
  GLOBAL // Taux global pour tous
  PARTNER // Taux spécifique à un partenaire
  AUTHOR // Taux spécifique à un auteur
  WORK // Taux spécifique à une œuvre
}

model Message {
  id          String    @id @default(cuid())
  subject     String
  content     String
  type        String    @default("MESSAGE")
  read        Boolean   @default(false)
  readAt      DateTime?
  senderId    String
  recipientId String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  recipient   User      @relation("ReceivedMessages", fields: [recipientId], references: [id])
  sender      User      @relation("SentMessages", fields: [senderId], references: [id])
}

model Notification {
  id        String    @id @default(cuid())
  userId    String
  title     String
  message   String
  type      String
  data      String?
  read      Boolean   @default(false)
  readAt    DateTime?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([createdAt])
  @@index([userId, read, createdAt])
  @@index([type, createdAt])
}

model NotificationTemplate {
  id          String   @id @default(cuid())
  code        String   @unique
  titre       String
  texte       String   @db.Text
  statut      String   @default("Actif") // Actif ou Inactif
  createdById String
  createdBy   User     @relation("CreatedNotificationTemplates", fields: [createdById], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  updatedById String?
  updatedBy   User?    @relation("UpdatedNotificationTemplates", fields: [updatedById], references: [id])

  @@index([code])
  @@index([statut])
  @@index([createdAt])
}

model NotificationChain {
  id            String   @id @default(cuid())
  title         String
  clientId      String? // ID du client concerné (peut être null pour tous les clients)
  client        User?    @relation("NotificationChains", fields: [clientId], references: [id])
  scheduledDate DateTime // Date et heure programmée
  sendSMS       Boolean  @default(true)
  sendEmail     Boolean  @default(true)
  daysBefore    Int      @default(1) // Nombre de jours avant l'événement
  status        String   @default("Actif") // Actif ou Désactivé
  message       String
  orderId       String? // ID de la commande si liée à une commande
  order         Order?   @relation("NotificationChainOrders", fields: [orderId], references: [id])
  createdById   String
  createdBy     User     @relation("CreatedNotificationChains", fields: [createdById], references: [id])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([clientId])
  @@index([status])
  @@index([scheduledDate])
  @@index([createdAt])
}

model AuditLog {
  id          String   @id @default(cuid())
  action      String
  userId      String?
  performedBy String
  details     String
  metadata    String?
  createdAt   DateTime @default(now())

  @@index([createdAt])
  @@index([userId])
  @@index([action])
  @@index([createdAt, userId])
  @@index([createdAt, action])
}

model AdvancedSetting {
  id          String   @id @default(cuid())
  key         String   @unique
  description String
  value       String
  type        String   @default("string")
  category    String?
  status      String   @default("Actif")
  updatedById String?
  updatedBy   User?    @relation("UpdatedAdvancedSettings", fields: [updatedById], references: [id])
  updatedAt   DateTime @updatedAt
  createdAt   DateTime @default(now())

  @@index([key])
  @@index([category])
  @@index([status])
}

model WorkVersion {
  id            String    @id @default(cuid())
  workId        String
  version       String
  title         String
  description   String?
  isActive      Boolean   @default(true)
  publishedAt   DateTime?
  archivedAt    DateTime?
  createdBy     String
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  createdByUser User      @relation(fields: [createdBy], references: [id])
  work          Work      @relation(fields: [workId], references: [id], onDelete: Cascade)

  @@index([workId])
  @@index([version])
  @@index([isActive])
}

model WorkSale {
  id         String   @id @default(cuid())
  workId     String
  quantity   Int
  amount     Float
  saleType   SaleType @default(DIRECT)
  customerId String?
  orderId    String?
  saleDate   DateTime @default(now())
  createdAt  DateTime @default(now())
  customer   User?    @relation(fields: [customerId], references: [id])
  work       Work     @relation(fields: [workId], references: [id], onDelete: Cascade)

  @@index([workId])
  @@index([saleDate])
  @@index([saleType])
}

model WorkDistribution {
  id               String           @id @default(cuid())
  workId           String
  quantity         Int
  distributionType DistributionType @default(SCHOOL)
  recipientId      String?
  recipientName    String?
  distributionDate DateTime         @default(now())
  notes            String?
  createdAt        DateTime         @default(now())
  work             Work             @relation(fields: [workId], references: [id], onDelete: Cascade)

  @@index([workId])
  @@index([distributionDate])
  @@index([distributionType])
}

model WorkView {
  id        String   @id @default(cuid())
  workId    String
  viewerId  String?
  ipAddress String?
  userAgent String?
  viewedAt  DateTime @default(now())
  viewer    User?    @relation(fields: [viewerId], references: [id])
  work      Work     @relation(fields: [workId], references: [id], onDelete: Cascade)

  @@index([workId])
  @@index([viewedAt])
  @@index([viewerId])
}

model StockAlertRule {
  id              String        @id @default(cuid())
  name            String
  description     String?
  type            AlertRuleType
  conditions      String
  actions         String
  isActive        Boolean       @default(true)
  priority        AlertPriority @default(MEDIUM)
  createdBy       String
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  triggeredAlerts StockAlert[]  @relation("AlertRule")
  createdByUser   User          @relation(fields: [createdBy], references: [id])

  @@index([type])
  @@index([isActive])
  @@index([priority])
}

model StockAlert {
  id             String          @id @default(cuid())
  ruleId         String?
  workId         String?
  type           AlertType
  severity       AlertSeverity
  title          String
  message        String
  data           String?
  isRead         Boolean         @default(false)
  isResolved     Boolean         @default(false)
  resolvedBy     String?
  resolvedAt     DateTime?
  createdAt      DateTime        @default(now())
  resolvedByUser User?           @relation(fields: [resolvedBy], references: [id])
  rule           StockAlertRule? @relation("AlertRule", fields: [ruleId], references: [id])
  work           Work?           @relation(fields: [workId], references: [id])

  @@index([type])
  @@index([severity])
  @@index([isRead])
  @@index([isResolved])
  @@index([createdAt])
}

model StockReport {
  id            String            @id @default(cuid())
  name          String
  type          ReportType
  parameters    String
  schedule      String?
  isActive      Boolean           @default(true)
  lastRun       DateTime?
  nextRun       DateTime?
  createdBy     String
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  executions    ReportExecution[] @relation("Report")
  createdByUser User              @relation(fields: [createdBy], references: [id])

  @@index([type])
  @@index([isActive])
  @@index([nextRun])
}

model ReportExecution {
  id          String          @id @default(cuid())
  reportId    String
  status      ExecutionStatus
  startedAt   DateTime        @default(now())
  completedAt DateTime?
  result      String?
  error       String?
  filePath    String?
  report      StockReport     @relation("Report", fields: [reportId], references: [id])

  @@index([reportId])
  @@index([status])
  @@index([startedAt])
}

model StockIntegration {
  id            String          @id @default(cuid())
  name          String
  type          IntegrationType
  config        String
  isActive      Boolean         @default(true)
  lastSync      DateTime?
  syncStatus    SyncStatus      @default(PENDING)
  errorCount    Int             @default(0)
  lastError     String?
  createdBy     String
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  createdByUser User            @relation(fields: [createdBy], references: [id])

  @@index([type])
  @@index([isActive])
  @@index([syncStatus])
}

enum Role {
  PDG
  REPRESENTANT
  CONCEPTEUR
  AUTEUR
  PARTENAIRE
  CLIENT
  INVITE
}

enum UserStatus {
  PENDING
  APPROVED
  REJECTED
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum ProjectStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  ACCEPTED // compat legacy (à migrer plus tard)
  APPROVED // nouveau officiel
  REJECTED
  ARCHIVED // nouveau officiel
}

enum WorkStatus {
  DRAFT
  PENDING
  PUBLISHED
  REJECTED
  ON_SALE
  OUT_OF_STOCK
  DISCONTINUED
  SUSPENDED
}

enum OrderStatus {
  PENDING
  VALIDATED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

enum PaymentType {
  CASH // Achat comptant (paiement complet immédiat)
  DEPOSIT // Dépôt (acompte + solde)
  CREDIT // Crédit (paiement différé/échelonné)
}

enum PaymentStatus {
  UNPAID // Non payé
  PARTIAL // Partiellement payé (dépôt versé)
  PAID // Entièrement payé
  OVERDUE // En retard de paiement
  CANCELLED // Annulé
}

enum DeliveryStatus {
  PENDING // En attente
  PREPARING // En préparation
  READY // Prêt pour livraison
  IN_TRANSIT // En cours de livraison
  DELIVERED // Livré
  RECEIVED // Réceptionné par le client
  FAILED // Échec de livraison
}

enum DeliveryNoteStatus {
  PENDING
  VALIDATED
  CONTROLLED
  COMPLETED
  CANCELLED
}

enum ProformaStatus {
  PENDING // Ancien statut pour compatibilité (sera migré vers DRAFT)
  DRAFT // Brouillon
  SENT // Envoyé au client
  AWAITING_RESPONSE // Ancien statut pour compatibilité
  ACCEPTED // Accepté par le client
  REJECTED // Ancien statut pour compatibilité
  CONVERTED // Ancien statut pour compatibilité (sera migré vers ACCEPTED)
  EXPIRED // Expiré
  CANCELLED // Annulé
}

enum ProformaClientType {
  ECOLE // École
  PARTENAIRE // Partenaire
  CLIENT // Client
  INVITE // Client invité (sans compte)
}

enum Currency {
  XOF // Franc CFA (Afrique de l'Ouest)
  XAF // Franc CFA (Afrique centrale)
  FCFA // Franc CFA (alias)
}

enum StockRequestStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSING
  DELIVERED
  CANCELLED
}

enum StockRequestType {
  COMMANDE
  PRECOMMANDE
  DEPOT
  REAPPROVISIONNEMENT
}

enum StockMovementType {
  INBOUND
  OUTBOUND
  ADJUSTMENT
  TRANSFER
  DAMAGED
  EXPIRED
  PARTNER_ALLOCATION
  PARTNER_SALE
  PARTNER_RETURN
  DIRECT_SALE
  CORRECTION
  INVENTORY
}

enum SaleType {
  DIRECT
  ONLINE
  PARTNER
  SCHOOL
  BULK
}

enum DistributionType {
  SCHOOL
  LIBRARY
  PARTNER
  PROMOTION
  SAMPLE
}

enum AlertRuleType {
  STOCK_LOW
  STOCK_OUT
  SALES_THRESHOLD
  PRICE_CHANGE
  EXPIRY_WARNING
  CUSTOM
}

enum AlertPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum AlertType {
  STOCK_LOW
  STOCK_OUT
  SALES_SPIKE
  PRICE_CHANGE
  EXPIRY_WARNING
  INTEGRATION_ERROR
  REPORT_FAILED
  CUSTOM
}

enum AlertSeverity {
  INFO
  WARNING
  ERROR
  CRITICAL
}

enum ReportType {
  INVENTORY_SUMMARY
  SALES_ANALYSIS
  STOCK_MOVEMENTS
  ALERTS_SUMMARY
  CUSTOM
}

enum ExecutionStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

enum IntegrationType {
  ORDER_SYSTEM
  ACCOUNTING_SYSTEM
  WAREHOUSE_SYSTEM
  ECOMMERCE_PLATFORM
  CUSTOM
}

enum SyncStatus {
  PENDING
  SYNCING
  SUCCESS
  FAILED
  DISABLED
}

// Modèle pour les codes promo et promotions
model Promotion {
  id               String          @id @default(cuid())
  libelle          String // Nom de la promotion
  code             String          @unique // Code promo unique
  periode          String // Période de validité (texte libre)
  startDate        DateTime? // Date de début (optionnel)
  endDate          DateTime? // Date de fin (optionnel)
  livre            String // Livres concernés
  statut           PromotionStatus @default(ACTIF)
  taux             String // Montant ou pourcentage de réduction
  quantiteMinimale Int             @default(1)
  description      String? // Description optionnelle
  createdBy        String // Créé par
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  @@index([code])
  @@index([statut])
}

enum PromotionStatus {
  ACTIF
  INACTIF
  EXPIRE
}

// Modèle pour les catégories de livres
model Category {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  isActive    Boolean  @default(true)
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([name])
  @@index([isActive])
}

// Modèle pour les classes scolaires
model SchoolClass {
  id        String   @id @default(cuid())
  name      String   @unique // ex: "CI", "CP", "CE1", etc.
  section   String // "Primaire" ou "Secondaire"
  isActive  Boolean  @default(true)
  createdBy String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
  @@index([section])
  @@index([isActive])
}

// Modèle pour les réductions (différent des promotions)
model Discount {
  id          String         @id @default(cuid())
  client      String // Type de client (Librairie, École, etc.)
  livre       String // Livres concernés
  quantiteMin Int            @default(1)
  reduction   Float // Montant de la réduction
  statut      DiscountStatus @default(ACTIF)
  description String?
  type        String         @default("Montant") // "Montant" ou "Pourcentage"
  image       String?
  createdBy   String
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([statut])
  @@index([client])
}

enum DiscountStatus {
  ACTIF
  INACTIF
}

// Modèle pour les clients (librairies, écoles, etc.)
model Client {
  id             String       @id @default(cuid())
  nom            String
  telephone      String?
  email          String?
  type           String // Concepteur, École, Librairie, Auteur, etc.
  departement    String?
  address        String?
  city           String?
  contact        String? // Personne de contact
  statut         ClientStatus @default(EN_ATTENTE)
  dette          Float        @default(0)
  notes          String?
  representantId String? // Représentant assigné
  totalOrders    Int          @default(0)
  totalSpent     Float        @default(0)
  lastOrder      DateTime?
  createdBy      String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@index([statut])
  @@index([type])
  @@index([representantId])
  @@index([email])
}

enum ClientStatus {
  EN_ATTENTE
  ACTIF
  INACTIF
  SUSPENDU
}

// Modèle pour les communications et diffusions
model Communication {
  id             String              @id @default(cuid())
  title          String
  message        String              @db.Text
  type           CommunicationType   @default(ANNOUNCEMENT)
  targetAudience String // JSON array des rôles ciblés
  status         CommunicationStatus @default(DRAFT)
  scheduledFor   DateTime?
  sentAt         DateTime?
  recipients     Int                 @default(0)
  readCount      Int                 @default(0)
  createdBy      String
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt

  @@index([status])
  @@index([type])
  @@index([createdAt])
}

enum CommunicationType {
  ANNOUNCEMENT
  NOTIFICATION
  PROMOTION
  POLICY
}

enum CommunicationStatus {
  DRAFT
  SCHEDULED
  SENT
  CANCELLED
}

// Modèle pour les paramètres globaux du système
model Setting {
  id        String   @id @default(cuid())
  category  String // platform, business, stock, pricing, notifications, security, audit
  key       String // Clé du paramètre
  value     String   @db.Text // Valeur (JSON ou texte)
  type      String   @default("string") // string, number, boolean, json
  updatedBy String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([category, key])
  @@index([category])
}
